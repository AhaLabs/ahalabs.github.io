{"pageProps":{"id":"wit-bringing-types-to-near-contracts","title":"`wit`: Bringing types to NEAR smart contracts","date":"2022-02-03","author":"@willemneal","markdown":"\n# NEAR and WebAssembly\n\nUnder the hood, NEAR uses WebAssembly (Wasm) to run smart contracts. While this is\ngreat, it has some pain points. For normal Wasm binaries, functions exported can\nonly have float and integer types. So more complex types like strings have to be\npassed via a pointer, `pass_string(len: u32, ptr: u32)`. This makes it hard to\ntell from the function signature that a string is being passed; it could be\nany binary blob.\n\nFor NEAR Wasm binaries this problem is made worse because all export functions have the same\ntype signature, `foo()`, that is they take no arguments and return nothing. The reason\nfor this is because the arguments are serialized in JSON, so the function first\nasks the host for a binary blob and then deserializes it.\n\nSo if you can download a contract's binary and inspect it, you'll only have the function names\nwith no other information.\n\n## Introducing the `wit` format\n\n[WebAssembly Interface Types](https://hacks.mozilla.org/2019/08/webassembly-interface-types/) seeks to solve the task of passing of more complex types at a low level.\n\nUntil this is complete the `wit-bindgen` project created a [`.wit`](https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md) format that can be used to generate the needed source \"`adapters`\" to handle passing the complex types.\n\nFor example, in JavaScript strings are encoded as `UTF-16`[note], but `UTF-8` in Rust. So\npassing the binary blob of the string from a Rust Wasm binary is not a simple copy/paste.\n\nFor our use case we need `remote adapters`.  Whereas `wit-bindgen` expects to pass values\nvia a normal function call, we are serializing values on one side of an RPC call and then deserializing them on the other.\n\n## `witme` a CLI tool for generating to and from `.wit`\n\nSo after that introduction let's walk through a real example. First `witme` is a Rust binary that can be installed with `cargo`:\n\n```bash\ncargo install witme\n```\n\nAssume that you have a Rust smart contract:\n\n```rust\nuse near_sdk::{witgen, near_bindgen}\n\n/// A message that contains some text\n#[witgen]\npub struct Message {\n  /// Inner string value\n  text: String,\n}\n\n//...\npub struct Contract {\n  message: Message\n}\n\n#[near_bindgen]\nimpl Contract {\n  \n  /// A change call to set the message\n  pub fn set_message(&mut self, message: Message) {\n    self.mesage = message;\n  }\n\n  /// A view call to get the current message\n  pub fn get_message(self) -> Message {\n    self.message\n  }\n}\n\n```\n\nThe view method `get_message` returns a `Message` struct. `#[witgen]` is a Rust macro that generates a corresponding [`wit` record](https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md#item-record-bag-of-named-fields). See the [witgen repo](https://github.com/bnjjj/witgen) to learn more about generating `.wit` files from existing code.\n\nFurthermore the `#[near_bindgen]` macro has been updated to generate [function types in `wit`](https://github.com/bytecodealliance/wit-bindgen/blob/main/WIT.md#item-function).\n\nNext you can use `witme` to generate a `.wit` file for the contract.\n\n```bash\nwitme near wit\n```\n\ngenerates `index.wit`\n\n```wit\n///  A message that contains some text\nrecord message {\n    ///  Inner string value\n    text: string\n}\n\n///  A change call to set the message\n///  change\nset-message: function(message: message)\n\n///  A view call to get the current message\nget-message: function() -> message\n\n```\n\nThis `wit` file now describes the Contract's interface in a language agnostic way. This means we can now generate source code for a different language.  For example, TypeScript:\n\n```bash\nwitme near ts\n```\n\nBy default this command looks for an `index.wit` and puts the generated TS in it's own `./ts` folder.\n\n```typescript\n/**\n* A message that contains some text\n*/\nexport interface Message {\n  /**\n  * Inner string value\n  */\n  text: string;\n}\n\nexport class Contract {\n  /** Account calling the contract and the contractId to call */\n  constructor(public account: Account, public readonly contractId: string){}\n  \n  /**\n  * A change call to set the message\n  */\n  async set_message(args: {\n    message: Message;\n  }, options?: ChangeMethodOptions): Promise<void> {}\n\n  /**\n  * A view call to get the current message\n  */\n  get_message(args = {}, options?: ViewFunctionOptions): Promise<Message> {}\n}\n```\n\nThis means the contract's interface is now available to use with `near-api-js` to interact with the contract.\n\n```ts\nimport {Contract, Message} from \"message/contract\";\nimport {Account} from \"near-api-js\";\n\nasync function getMessage(currentAccount: Account): Promise<Message> {\n  let contract = new Contract(currentAccount, \"contract.testnet\");\n  return contract.get_message();\n}\n```\n\nSince the original comments in the rust code are preserved you can also get hover over docs in your IDE, or generate a documentation website (see [TenK's docs](https://tenk-dao.github.io/tenk/docs/) for an example).\n\n## JSON Schema\n\nTaking this a step further we can generate a [json-schema](https://json-schema.org/), basically a JSON object that defines the constraints of the data to allow a JSON object to be validated.\n\n```bash\nwitme near json\n```\n\nCurrently this is supported by using a [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator). Though this too could be generated directly from the `.wit`.  This command defaults to find a `./ts/index.ts`, which it uses to generate a `index.schema.json`.\n\nWhich would look something like\n\n```json\n{\n  \"GetMessage\": {\n    \"additionalProperties\": false,\n    \"contractMethod\": \"view\",\n    \"description\": \"A view call to get the current message\",\n    \"properties\": {\n      \"args\": {\n        \"additionalProperties\": false,\n        \"type\": \"object\"\n      }\n    },\n    \"required\": [\n      \"args\"\n    ],\n    \"type\": \"object\"\n  },\n \"SetMessage\": {\n    \"additionalProperties\": false,\n    \"contractMethod\": \"change\",\n    \"description\": \"A change call to set the message\",\n    \"properties\": {\n      \"args\": {\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"message\": {\n            \"$ref\": \"#/definitions/Message\"\n          }\n        },\n        \"required\": [\n          \"message\"\n        ],\n        \"type\": \"object\"\n      },\n      \"options\": {\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"attachedDeposit\": {\n            \"$ref\": \"#/definitions/Balance\",\n            \"default\": \"0\",\n            \"description\": \"Units in yoctoNear\"\n          },\n          \"gas\": {\n            \"default\": \"30000000000000\",\n            \"description\": \"Units in gas\",\n            \"pattern\": \"[0-9]+\",\n            \"type\": \"string\"\n          }\n        },\n        \"type\": \"object\"\n      }\n    },\n    \"required\": [\n      \"args\",\n      \"options\"\n    ],\n    \"type\": \"object\"\n    },\n  \"Message\": {\n    \"additionalProperties\": false,\n    \"description\": \"A message that contains some text\",\n    \"properties\": {\n      \"text\": {\n        \"description\": \"Inner string value\",\n        \"type\": \"string\"\n      }\n    },\n    \"required\": [\n      \"text\"\n    ],\n    \"type\": \"object\"\n  },\n}\n```\n\nFirst we can see `GetMessage` is a `view` function and requires an `args` object that has no properties. Next `SetMessage` requires an `args` object with one field \"`message`\", the type of which is a reference to the `Message` type defined in the schema. Since `SetMessage` is a `change` function, an `options` field is also required for how much gas and deposit to attached to the transaction.\n\nWhereas the Typescript would provide compile time checks that the types used in the contract call are valid, this allows the arguments passed to a contract method at runtime to be validated, thus preventing errors before they reach a NEAR node.\n\n\n### Forms for free\n\nNow that we have a schema and know all of the input types, a React form can be autogenerated to validate and interact with the contract.  Not only are the types validated, but extra annotations can be used to add additional constraints.\n\nFor example, if the text of every message had to start with \"`TEXT:`\" a regular expression can be added to the comments.\n\n```rust\n/// A message that contains some text\n#[witgen]\npub struct Message {\n  /// Inner string value\n  /// @pattern ^TEXT:\n  text: String,\n}\n```\n\n```ts\n/**\n* A message that contains some text\n*/\nexport interface Message {\n  /**\n  * Inner string value\n  * @pattern ^TEXT:\n  */\n  text: string;\n}\n```\n\n```json\n{\n  \"Message\": {\n    \"additionalProperties\": false,\n    \"description\": \"A message that contains some text\",\n    \"properties\": {\n      \"text\": {\n        \"description\": \"Inner string value\",\n        \"pattern\": \"^TEXT:\",\n        \"type\": \"string\"\n      }\n    },\n    \"required\": [\n      \"text\"\n    ],\n    \"type\": \"object\"\n  },\n}\n```\n\nThis is showcased in the TenK repo's admin panel: [https://tenk-dao.github.io/tenk](https://tenk-dao.github.io/tenk/#/mint_rate_limit.tenk.testnet/NftTokensForOwner). Try entering \".\" for the `account_id` and hit submit or check `live validation` and you'll get the following error:\n\n``` js\n.args.account_id should NOT be shorter than 2 characters\n.args.account_id should match pattern \"^(([a-z\\d]+[-_])*[a-z\\d]+\\.)*([a-z\\d]+[-_])*[a-z\\d]+$\"\n```\n\n## Future Plans\n\nOur future plans include: adding rust code generation for testing and for making cross contract calls more user friendly; adding borsh support for more efficient serialization than json; adding custom transformations for schema fields, allowing passing values like \"10 N\" instead of \"10000000000000000000000000\"; making the form dynamic for targeting different contracts; and lastly creating a wit registry for deployed contracts.\n"},"__N_SSG":true}